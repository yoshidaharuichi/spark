<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mok WebAR ç²’å­ç³»ç»Ÿ (ä¿®å¤ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* ææ·±çš„ç°åº•ï¼Œéçº¯é»‘ï¼Œä¾¿äºè°ƒè¯• */
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #video-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0; /* ä¿æŒéšè—ï¼Œåªç”¨ä½œè®¡ç®—æ•°æ®æº */
            z-index: 0;
            transform: scaleX(-1);
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            z-index: 10;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        h1 { margin: 0; font-size: 24px; letter-spacing: 2px; text-transform: uppercase; }
        .status { font-size: 16px; margin-top: 8px; font-weight: bold; color: #fff; }
        .sub-status { font-size: 12px; color: #aaa; margin-top: 4px; }
        .instructions {
            margin-top: 20px;
            font-size: 12px;
            line-height: 1.8;
            background: rgba(0, 20, 20, 0.7);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #00ffff;
            max-width: 280px;
        }
        #loading {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 14px;
            z-index: 20;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid #00ffff;
            pointer-events: none;
        }
        /* å¢åŠ ä¸€ä¸ªè°ƒè¯•æŒ‰é’®ï¼Œä¸‡ä¸€æ‘„åƒå¤´å½»åº•æŒ‚äº†å¯ä»¥ç”¨é¼ æ ‡ç© */
        #debug-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 30;
            pointer-events: auto;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: none; /* é»˜è®¤éšè— */
        }
    </style>
    
    <!-- Three.js (ä½¿ç”¨ç¨³å®šç‰ˆæœ¬) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <!-- MediaPipe Hands (ä½¿ç”¨ jsdelivr ä»¥æé«˜ç¨³å®šæ€§) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>MOK ç²’å­å¼•æ“</h1>
        <div class="status" id="status-text">ç³»ç»Ÿå¯åŠ¨ä¸­...</div>
        <div class="sub-status" id="mode-text">æ¨¡å¼: è‡ªåŠ¨æ¼”ç¤º (ç­‰å¾…æ‘„åƒå¤´)</div>
        
        <div class="instructions">
            <strong>ğŸ– å¼ æ‰‹</strong>: èšå˜çƒä½“<br>
            <strong>âœŒï¸ å‰ªåˆ€æ‰‹</strong>: ç”Ÿæˆ "æˆ‘æ˜¯ Yun"<br>
            <strong>âœŠ æ¡æ‹³</strong>: èƒ½é‡åœ†ç¯<br>
            <strong>ğŸ‘† é£ŸæŒ‡</strong>: æ˜Ÿè¾°å½¢æ€<br>
            <strong>ğŸ‘ ç«–å¤§æ‹‡æŒ‡</strong>: çˆ±å¿ƒåŠ›åœº<br>
        </div>
    </div>

    <div id="loading">æ­£åœ¨è¿æ¥è§†è§‰æ ¸å¿ƒ...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    <button id="debug-btn" onclick="toggleAutoMode()">åˆ‡æ¢æ¼”ç¤ºæ¨¡å¼</button>

    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

<script>
// --- é…ç½®å‚æ•° ---
const CONFIG = {
    particleCount: 12000, // ç¨å¾®é™ä½ä¸€ç‚¹æ•°é‡ä»¥ç¡®ä¿ä½ç«¯è®¾å¤‡ä¸é»‘å±
    color: 0x00ffff,
    particleSize: 0.4, // å¢å¤§ç²’å­å°ºå¯¸ç¡®ä¿å¯è§
    damping: 0.92, 
    stiffness: 0.12, 
    explosionForce: 1.5,
    autoChangeInterval: 3000 // è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼åˆ‡æ¢é—´éš”
};

// --- å…¨å±€å˜é‡ ---
let scene, camera, renderer, particlesGeometry, particlesMaterial;
let particleSystem = {
    positions: null,
    velocities: null,
    targetPositions: null
};
let isHandPresent = false;
let isAutoMode = true; // é»˜è®¤å¼€å¯è‡ªåŠ¨æ¨¡å¼ï¼Œæ£€æµ‹åˆ°æ‰‹åå…³é—­
let lastHandTime = 0;
let handCentroid = new THREE.Vector3();
let handVelocity = new THREE.Vector3();
let lastHandPos = new THREE.Vector3();
let currentGesture = 'NONE';
let globalScale = 1.0;
let time = 0;

// --- å½¢çŠ¶æ•°æ® ---
const Shapes = { SPHERE: [], TEXT: [], RING: [], STAR: [], HEART: [] };

// --- å…¥å£ ---
window.onload = function() {
    initThree();        // 1. å…ˆæå®š 3D åœºæ™¯
    generateTexture();  // 2. ç”Ÿæˆæè´¨è´´å›¾ (ä¸ä¾èµ–ç½‘ç»œ)
    precomputeShapes(); // 3. ç®—å¥½å½¢çŠ¶
    initParticles();    // 4. æ”¾å…¥ç²’å­
    startAnimation();   // 5. ç«‹åˆ»å¼€å§‹åŠ¨ç”»å¾ªç¯ (ä¸è¦ç­‰æ‘„åƒå¤´!)
    
    // 6. æœ€åå°è¯•åŠ è½½æ‘„åƒå¤´ï¼Œå¤±è´¥ä¹Ÿæ²¡å…³ç³»ï¼Œè‡³å°‘æœ‰åŠ¨ç”»çœ‹
    setTimeout(setupMediaPipe, 100); 
};

// 1. Three.js åˆå§‹åŒ–
function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    // ç¨å¾®å¸¦ç‚¹è“è‰²çš„èƒŒæ™¯ï¼Œä¸é‚£ä¹ˆæ­»é»‘
    scene.background = new THREE.Color(0x050a10);
    scene.fog = new THREE.FogExp2(0x050a10, 0.03);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 25; // æ‹‰è¿œä¸€ç‚¹ï¼Œç¡®ä¿èƒ½çœ‹åˆ°ä¸­å¿ƒ

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // ç¯å…‰ (è™½ç„¶ç²’å­è‡ªå‘å…‰ï¼Œä½†ä¸ºäº†å¿ƒç†å®‰æ…°åŠ ä¸ªå…‰)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

// 2. åŠ¨æ€ç”Ÿæˆç²’å­çº¹ç† (å…³é”®ä¿®å¤ï¼šä¸å†åŠ è½½å¤–éƒ¨å›¾ç‰‡)
let particleTexture;
function generateTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');
    
    // ç”»ä¸€ä¸ªå¾„å‘æ¸å˜çš„å‘å…‰çƒ
    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
    grad.addColorStop(0.4, 'rgba(0, 255, 255, 0.8)');
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 32, 32);
    
    particleTexture = new THREE.CanvasTexture(canvas);
}

// 3. é¢„è®¡ç®—å½¢çŠ¶
function precomputeShapes() {
    const count = CONFIG.particleCount;

    // çƒä½“
    const phi = Math.PI * (3 - Math.sqrt(5)); 
    for (let i = 0; i < count; i++) {
        const y = 1 - (i / (count - 1)) * 2; 
        const radius = Math.sqrt(1 - y * y);
        const theta = phi * i; 
        const r = 8; // åŠå¾„
        Shapes.SPHERE.push(Math.cos(theta) * radius * r, y * r, Math.sin(theta) * radius * r);
    }

    // åœ†ç¯
    for (let i = 0; i < count; i++) {
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI * 2;
        const R = 6; 
        const r = 2; 
        const x = (R + r * Math.cos(v)) * Math.cos(u);
        const y = (R + r * Math.cos(v)) * Math.sin(u);
        const z = r * Math.sin(v);
        Shapes.RING.push(x, y, z);
    }

    // æ˜Ÿæ˜Ÿ
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const rBase = 8;
        // ç®€å•çš„äº”è§’æ˜Ÿæåæ ‡æ¨¡æ‹Ÿ
        const rMod = (Math.pow(Math.cos(5 * angle), 2) * 0.6 + 0.4) * rBase; 
        const r = Math.sqrt(Math.random()) * rMod; 
        const z = (Math.random() - 0.5) * 3;
        Shapes.STAR.push(r * Math.cos(angle), r * Math.sin(angle), z);
    }

    // çˆ±å¿ƒ
    for (let i = 0; i < count; i++) {
        let x, y, z;
        // å¿«é€Ÿè¿‘ä¼¼ç”Ÿæˆ
        const t = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random());
        // çˆ±å¿ƒå‚æ•°æ–¹ç¨‹
        x = 16 * Math.pow(Math.sin(t), 3);
        y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        // å½’ä¸€åŒ–å¹¶ç¼©æ”¾
        x *= 0.5 * r;
        y *= 0.5 * r;
        z = (Math.random() - 0.5) * 4;
        Shapes.HEART.push(x, y + 2, z); // y+2 ç¨å¾®ä¸Šç§»
    }

    // æ–‡å­—
    generateTextShape();
}

function generateTextShape() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const size = 512;
    canvas.width = size;
    canvas.height = size;
    
    ctx.font = 'bold 120px Arial';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('æˆ‘æ˜¯', size/2, size/2 - 60);
    ctx.fillText('Yun', size/2, size/2 + 60);

    const data = ctx.getImageData(0,0,size,size).data;
    const points = [];
    const step = 4; // é‡‡æ ·æ­¥é•¿
    for(let y=0; y<size; y+=step) {
        for(let x=0; x<size; x+=step) {
            if(data[(y*size+x)*4] > 128) {
                points.push({
                    x: (x/size - 0.5) * 18,
                    y: -(y/size - 0.5) * 18 // åè½¬Y
                });
            }
        }
    }

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const p = points[i % points.length];
        Shapes.TEXT.push(p.x, p.y, (Math.random()-0.5)*2);
    }
}

// 4. ç²’å­ç³»ç»Ÿ
function initParticles() {
    particlesGeometry = new THREE.BufferGeometry();
    const posArray = new Float32Array(CONFIG.particleCount * 3);
    
    particleSystem.positions = posArray;
    particleSystem.velocities = new Float32Array(CONFIG.particleCount * 3);
    particleSystem.targetPositions = new Float32Array(CONFIG.particleCount * 3);

    // åˆå§‹ä½ç½®ï¼šå…ˆæ”¾åœ¨å±å¹•ä¸­é—´ä¹±é£ï¼Œä¸è¦æ”¾å¤ªè¿œ
    for(let i=0; i<CONFIG.particleCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 50;
        particleSystem.velocities[i] = 0;
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

    particlesMaterial = new THREE.PointsMaterial({
        color: CONFIG.color,
        size: CONFIG.particleSize,
        map: particleTexture, // ä½¿ç”¨ç”Ÿæˆçš„çº¹ç†
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
    });

    const mesh = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(mesh);

    // ç«‹å³è®¾ç½®åˆå§‹å½¢çŠ¶
    setTargetShape(Shapes.SPHERE);
    document.getElementById('status-text').innerText = "ç³»ç»Ÿå°±ç»ª - ç­‰å¾…ä¿¡å·";
}

function setTargetShape(shapeData) {
    if(!shapeData || shapeData.length === 0) return;
    for(let i=0; i<CONFIG.particleCount * 3; i++) {
        particleSystem.targetPositions[i] = shapeData[i];
    }
    // çˆ†ç‚¸ç‰¹æ•ˆ
    const vels = particleSystem.velocities;
    for(let i=0; i<vels.length; i++) {
        vels[i] += (Math.random()-0.5) * CONFIG.explosionForce;
    }
}

// 5. æ¸²æŸ“å¾ªç¯
function startAnimation() {
    let lastAutoChange = 0;
    const shapes = Object.keys(Shapes);
    let autoIndex = 0;

    function loop(t) {
        requestAnimationFrame(loop);
        time = t;

        // è‡ªåŠ¨æ¼”ç¤ºé€»è¾‘
        if (isAutoMode && !isHandPresent) {
            if (t - lastAutoChange > CONFIG.autoChangeInterval) {
                lastAutoChange = t;
                const nextShape = shapes[autoIndex++ % shapes.length];
                setTargetShape(Shapes[nextShape]);
                document.getElementById('status-text').innerText = "æ¼”ç¤ºæ¨¡å¼: " + nextShape;
            }
            // è‡ªåŠ¨æ¨¡å¼ä¸‹è½»å¾®å‘¼å¸ç¼©æ”¾
            globalScale = 1.0 + Math.sin(t * 0.002) * 0.1;
        }

        updatePhysics();
        
        // æ•´ä½“æ—‹è½¬
        scene.rotation.y = t * 0.0002;
        
        renderer.render(scene, camera);
    }
    loop(0);
}

function updatePhysics() {
    const pos = particleSystem.positions;
    const target = particleSystem.targetPositions;
    const vel = particleSystem.velocities;

    // æ‰‹åŠ¿é£æš´å‚æ•°
    let windX=0, windY=0, windZ=0;
    const hasStrongWind = isHandPresent && handVelocity.lengthSq() > 0.01;
    if(hasStrongWind) {
        windX = handVelocity.x * 0.2;
        windY = handVelocity.y * 0.2;
        windZ = handVelocity.z * 0.2;
    }

    for(let i=0; i<CONFIG.particleCount; i++) {
        const idx = i*3;
        
        // å¼¹ç°§åŠ›
        const tx = target[idx] * globalScale;
        const ty = target[idx+1] * globalScale;
        const tz = target[idx+2] * globalScale;

        const ax = (tx - pos[idx]) * CONFIG.stiffness;
        const ay = (ty - pos[idx+1]) * CONFIG.stiffness;
        const az = (tz - pos[idx+2]) * CONFIG.stiffness;

        vel[idx] += ax;
        vel[idx+1] += ay;
        vel[idx+2] += az;

        // äº¤äº’åŠ›
        if(isHandPresent) {
            const dx = pos[idx] - handCentroid.x;
            const dy = pos[idx+1] - handCentroid.y;
            const dz = pos[idx+2]; // å‡è®¾æ‰‹åœ¨ z=0 å¹³é¢é™„è¿‘
            
            // æ–¥åŠ›/é£åŠ›
            const distSq = dx*dx + dy*dy + dz*dz;
            if(distSq < 40) { // å½±å“èŒƒå›´
                const f = 10 / (distSq + 0.1);
                // æŒ¥æ‰‹æ—¶çš„é£
                if(hasStrongWind) {
                    vel[idx] += windX * f + (Math.random()-0.5)*0.5;
                    vel[idx+1] += windY * f + (Math.random()-0.5)*0.5;
                    vel[idx+2] += windZ * f + (Math.random()-0.5)*0.5;
                }
            }
        }

        vel[idx] *= CONFIG.damping;
        vel[idx+1] *= CONFIG.damping;
        vel[idx+2] *= CONFIG.damping;

        pos[idx] += vel[idx];
        pos[idx+1] += vel[idx+1];
        pos[idx+2] += vel[idx+2];
    }
    particlesGeometry.attributes.position.needsUpdate = true;
}

// 6. MediaPipe é€»è¾‘
async function setupMediaPipe() {
    const loadingEl = document.getElementById('loading');
    const statusEl = document.getElementById('status-text');
    const modeEl = document.getElementById('mode-text');

    try {
        const videoElement = document.getElementById('video-input');
        
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.5
        });

        hands.onResults(results => {
            // åªè¦æœ‰ä¸€æ¬¡æˆåŠŸï¼Œå°±éšè— loading
            loadingEl.style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // æ£€æµ‹åˆ°æ‰‹ï¼Œå…³é—­è‡ªåŠ¨æ¨¡å¼
                if(Date.now() - lastHandTime > 1000) {
                    isAutoMode = false;
                    modeEl.innerText = "æ¨¡å¼: å®æ—¶äº’åŠ¨";
                }
                lastHandTime = Date.now();
                isHandPresent = true;
                
                const lm = results.multiHandLandmarks[0];
                handleHandData(lm);
            } else {
                isHandPresent = false;
                // å¦‚æœæ‰‹ç¦»å¼€è¶…è¿‡5ç§’ï¼Œæ¢å¤è‡ªåŠ¨æ¼”ç¤º
                if (!isAutoMode && Date.now() - lastHandTime > 5000) {
                    isAutoMode = true;
                    modeEl.innerText = "æ¨¡å¼: è‡ªåŠ¨æ¼”ç¤º (æ‰‹å·²ç¦»å¼€)";
                }
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        await cameraUtils.start();
        
    } catch (e) {
        console.error(e);
        loadingEl.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œå·²åˆ‡æ¢è‡³çº¯å±•ç¤ºæ¨¡å¼";
        loadingEl.style.color = "#ff5555";
        document.getElementById('debug-btn').style.display = 'block';
    }
}

function handleHandData(lm) {
    // æ˜ å°„åæ ‡ 0..1 -> -15..15
    // æ³¨æ„ï¼šMediaPipe xåæ ‡æ˜¯é•œåƒçš„ï¼Œéœ€è¦åè½¬
    const x = (0.5 - lm[9].x) * 35; 
    const y = (0.5 - lm[9].y) * 25;
    
    // è®¡ç®—é€Ÿåº¦
    const currentPos = new THREE.Vector3(x, y, 0);
    handVelocity.subVectors(currentPos, lastHandPos);
    lastHandPos.copy(currentPos);
    handCentroid.set(x, y, 0);

    // æ·±åº¦æ¨æ‹‰ (åŸºäºæ‰‹æŒå¤§å°)
    const palmLen = Math.abs(lm[0].y - lm[12].y); // æ‰‹è…•åˆ°ä¸­æŒ‡
    const targetScale = 0.5 + palmLen * 3.0;
    globalScale += (targetScale - globalScale) * 0.1;

    // æ‰‹åŠ¿è¯†åˆ«
    const isThumbUp = lm[4].y < lm[3].y;
    const isIndexOpen = lm[8].y < lm[6].y;
    const isMiddleOpen = lm[12].y < lm[10].y;
    const isRingOpen = lm[16].y < lm[14].y;
    const isPinkyOpen = lm[20].y < lm[18].y;

    let gesture = 'UNKNOWN';
    const openCount = [isIndexOpen, isMiddleOpen, isRingOpen, isPinkyOpen].filter(Boolean).length;

    if (openCount === 4 && isThumbUp) gesture = 'OPEN_HAND';
    else if (openCount === 0) gesture = 'FIST';
    else if (isIndexOpen && isMiddleOpen && !isRingOpen) gesture = 'VICTORY';
    else if (isIndexOpen && !isMiddleOpen && !isRingOpen) gesture = 'INDEX_POINT';
    else if (isThumbUp && !isIndexOpen) gesture = 'THUMB_UP';

    if (gesture !== currentGesture && gesture !== 'UNKNOWN') {
        currentGesture = gesture;
        const statusEl = document.getElementById('status-text');
        
        switch(gesture) {
            case 'OPEN_HAND': setTargetShape(Shapes.SPHERE); statusEl.innerText = "çŠ¶æ€: èšå˜çƒä½“"; break;
            case 'VICTORY': setTargetShape(Shapes.TEXT); statusEl.innerText = "çŠ¶æ€: èº«ä»½è¯†åˆ«"; break;
            case 'FIST': setTargetShape(Shapes.RING); statusEl.innerText = "çŠ¶æ€: èƒ½é‡ç¯"; break;
            case 'INDEX_POINT': setTargetShape(Shapes.STAR); statusEl.innerText = "çŠ¶æ€: æ˜Ÿè¾°"; break;
            case 'THUMB_UP': setTargetShape(Shapes.HEART); statusEl.innerText = "çŠ¶æ€: æ ¸å¿ƒåŠ›åœº"; break;
        }
    }
}

// è°ƒè¯•æŒ‰é’®åŠŸèƒ½
window.toggleAutoMode = function() {
    isAutoMode = !isAutoMode;
    document.getElementById('mode-text').innerText = isAutoMode ? "æ¨¡å¼: è‡ªåŠ¨æ¼”ç¤º" : "æ¨¡å¼: æš‚åœ";
}

</script>
</body>
</html>